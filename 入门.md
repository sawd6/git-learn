## 关于Git Merge
![merge image0](merge0.png)  
在这张图中，当运行`git checkout bugfix; git merge main`时，会执行**快速合并**，即把bugfix的指针移到main，快速提交当**要合并的分支是当前分支的子分支才会发生**，如下图
![merge image1](merge1.png)
## 关于Git Rebase
![rebase image0](rebase0.png)  
`git rebase`的作用是将当前分支**相对于共同祖先**的提交，重新replay[^1]到目标分支的最新提交之后，并更新当前分支指针的位置。  
![rebase image1](rebase1.png)  
`git rebase b1 b2`网站中会将b2变基到b1并切换分支到b2。实际的Git中我还没有测试  
[^1]: 即按**变更顺序**应用到目标分支的最新提交之后
## 关于Git Checkout
`git checkout -b demo`新建一个demo分支并切换到该分支  
`git checkout 哈希值`分离HEAD指针，即让其指向某个**具体的提交记录**而不是分支名  
注意：由于git的哈希值基于SHA-1，有40位，所以肯定不可能输入所有，对于此你只需要输入哈希值的前几位就可。当然，也不可能每一次都通过哈希值改变HEAD指针的位置，所以你可以使用相对位置。  
![checkout image0](checkout0.png)
我们使用`git checkout bugFix^`来达成这一点。`git checkout demo^^`两个'^'就是移动两级咯~  
使用`git checkout bugFix~3`来移动多次（如果有的话）。下面是一个例题：  
初始是这样的  
![checkout image1](checkout1.png)  
`git branch -f main C6`
![checkout image2](checkout2.png)  
`git branch -f bugFix main~4`
![checkout image3](checkout3.png)  
`git checkout HEAD^`
![checkout image4](checkout4.png)  
这就通关了。注意`git branch -f demo HEAD~2`或者`git branch -f demo main^`两种都可，无论是基于HEAD还是某一分支。`-f`是强制操作。
## 关于Git Reset和Git Revert
使用`git reset HEAD^`回退提交记录来撤销改动。  
**注意**：在reset后，C2做的变更还在，但是处于**未加入暂存区状态**  
![image reset0](reset0.png)  
在本地分支使用`git reset`，这种改写提交历史的方法对远程分支**无效**。为了撤销更改并分享给别人，需要使用`git revert`。    
![image revert0](revert0.png)  
观察上图，我们要撤销的C2记录后多了一个新纪录C2'，这是因为新提交记录C2'**引入了更改**，这些更改是用来撤销C2提交的，也就是说C2'状态与C1相同。  
注意：`git reset`是回溯提交，即回到还没有执行`git add`时，所以要执行`git reset HEAD^`，不要忘记^。而`git revert`是计算当前更改并产生一个撤销当前更改的提交，所以应当是`git revert HEAD`。此时没有^。
## 整理提交记录
### Git Cherry-pick
`git cherry-pick <提交号>...`  
多说无益，看图  
![image cherry-pick0](cherry-pick0.png)  
~~施法~~`git cherry-pick C2 C4`  
![image cherry-pick1](cherry-pick1.png)  
### 交互式rebase
指的是带参数的rebase命令，`--interactive`，简写`-i`。  
Git会打开一个UI界面辅助你，列出**将要被复制到目标分支的备选提交记录**。还会显示每个提交记录的哈希值和提交说明，提交说明有助于理解这个提交进行了哪些更改。  
![image rebasei0](rebasei0.png)  
**CONFIRM!!!!!**  
![image rebasei1](rebasei1.png)
### 本地栈式提交
没啥可说的，就是只把比较重要的提交记录复制到我想要的位置。就`cherry-pick`和`git rebase -i`熟练使用  
来看一道例题。我们分别使用两种方法来做。初始是这样的：  
![image rebase2](rebase2.png)  
我们要想办法把它变成下图：  
![image rebase3](rebase3.png)
#### 法一
`git rebase main -i`  
![image rebase4](rebase4.png)  
**CONFIRM!!!**  
![image rebase5](rebase5.png)  
`git checkout main`  
`git merge bugFix`
![image rebase6](rebase6.png)  
过关。
#### 法二
`git checkout main`  
`git cherry-pick C4`
![image rebase7](rebase7.png)  
也能过关。
### 提交的技巧一
思考如下场景：  
![image tip0](tip0.png)  
![image tip1](tip1.png)  
针对上图，做如下解释：  
`git commit --amend`命令用来**修改最近一次的提交**。  
补充：原来的提交记录并非被完全删除，使用`git reflog`仍可找回，关于本命令的使用，后续会继续补充  
`git commit --amend --no-edit`仅仅提交，不修改上一次的提交信息  
*如果不加--no-edit，git会尝试唤起配置的编辑器，在Linux就是Vim，对提交信息进行修改。如果你仅仅是想替换个文件之类的，可以不用每次都在编辑器里确认*  
`git commit --amend -m "新的信息"`提交并修改提交信息为新的信息  
[更多用法](https://chat.deepseek.com/a/chat/s/f132194b-e17e-46d0-aced-9cafec0368d2)  
\#1题目  
![image tip2](tip2.png)  
下图是我们需要达成的目标  
![image tip3](tip3.png)  
前几步都是一样的  
`git rebase -i main`  
![image tip4](tip4.png)  
**CONFIRM!!!**  
`git commit ---amend`  
![image tip5](tip5.png)  
`git rebase -i main`改回来顺序  
![image tip6](tip6.png)  
**CONFIRM!!!**  
![image tip7](tip7.png)  
从这里开始，命令有了差异
#### 法一
`git checkout main`  
`git merge caption`  
![image tip8](tip8.png)  
过关。但以上两句可以用一行别的命令替代：
#### 法二
`git branch -f main caption`还记得这个吗？这条命令强制将main分支移动到指定的提交位置。不过，**直接使用该命令有风险**，请务必确定好再使用！  
![image tip9](tip9.png)  
值得注意的一点是，该条命令**不会**改变当前所在分支。
### 提交的技巧二
> 要在心里牢记 cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上<b>（只要不是 HEAD 上游的提交就没问题）</b>。  
其实并不是不可以，是因为会出现逻辑、安全等问题。[参考](https://chat.deepseek.com/a/chat/s/f132194b-e17e-46d0-aced-9cafec0368d2)  
再加深一下印象吧。  
\#2题目  
![image tip1_0](tip10.png)  
目标  
![image tip1_1](tip11.png)  
`git checkout main`  
`git cherry-pick C2`  
![image tip1_2](tip12.png)  
`git commit --amend`模拟修改  
![image tip1_3](tip13.png)  
`git cherry-pick C3`  
![image tip1_4](tip14.png)  
过关。
## Git Tags
> 相信通过前面课程的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？

我们可以通过给某个提交记录设置标签`tags`，来起到一个标志作用，因为标签不会随着提交而发生改变。  
`git tag v1 C1`指定一个C1处的标签v1。（如果不写提交记录哈希，会自动将标签设为当前HEAD指向的位置。）  
后续在此补充标错标签咋删。
## Git Describe 
> 标签在代码库中起着锚点的作用，而该命令则可以帮助你找到最近的锚点（标签）。Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 git bisect（一个查找产生 Bug 的提交记录的指令）（这个坑以后再填）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时（划掉）， 可能会用到这个命令。

Git Describe语法如下：  
`git describe <ref>`  
\<ref>可以是任何能被git识别成提交记录的引用，如果没有指定，git会使用HEAD指向的位置。  
它的输出结果是这样的：  
`<tag>-<numCommits>-g<hash>`  
tag: 离ref最近的标签  
numCommits: ref与tag相差的提交记录数  
hash: 给定的ref表示的提交记录哈希值的前几位，*当ref提交记录上有某个标签时，则只输出标签名称*  
举个栗子  
![image](describe0.png)  
## 关于远程分支
### Git Clone
运行了`git clone`后，本地仓库会多一个名叫**origin/main**的分支，这种类型的分支就叫**远程分支**。远程分支反映了远程仓库（在你上次和它通信时）的状态。它有一个特别的属性，即在切换到远程分支时，自动进入**分离HEAD**状态。如下图  
![image clone0](clone0.png)  
即便添加新的提交，origin/main（图中简写o/main）也不会更新，这是因为该分支仅在远程仓库中的对应分支更新后了它才会更新。  
### Git Fetch要注意的几点
`git fetch`不会改变本地仓库的状态，它不会更新main分支，以及**不会修改磁盘上的文件**。
### Git Push要注意的几点
不带参`git push`默认行为和配置文件有关。所以尽量明确写明参数，除非你知道配置文件写的是什么。  
当运行`git push`，不仅远程仓库中分支会被更新，我们的*远程分支*（origin/main）也会更新